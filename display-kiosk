#!/usr/bin/python2.7
# -*- coding: utf-8 -*-

"""Displays kiosk displays a website in a stripped down kiosk."""

from PySide.QtCore import *
from PySide.QtGui import *
from PySide.QtNetwork import *
from PySide.QtWebKit import *

import sys
import argparse


class WebPage(QWebPage):
    def __init__(self, tab):
        super(WebPage, self).__init__()
        self.tab = tab

    def createWindow(self, webWindowType):
        tab = KioskTab(self.tab.tabs)

        page = tab.view.page()
        page.setNetworkAccessManager(self.networkAccessManager())
        return tab.view.page()

    def supportsExtension(self, extension):
        if extension == QWebPage.ErrorPageExtension:
            return True
        elif extension == QWebPage.ChooseMultipleFilesExtension:
            if self.tab.tabs.settings.prevent_upload:
                return False
            else:
                return super(WebPage, self).supportsExtension(extension)

        return False

    def extension(self, extension, option, output):
        if extension == QWebPage.ErrorPageExtension:
            if option.domain == QWebPage.QtNetwork:
                self.tab.statusBar.showMessage("Network error: %s" % option.errorString)
            elif option.domain == QWebPage.Http:
                self.tab.statusBar.showMessage("HTTP error: %s" % option.errorString)
            elif option.domain == QWebPage.WebKit:
                self.tab.statusBar.showMessage("WebKit error: %s" % option.errorString)
        else:
            return super(WebPage, self).extension(extension, option, output)

    def chooseFile(self, webFrame, suggestedFileName):
        if self.tab.tabs.settings.prevent_upload:
            self.tab.statusBar.showMessage(u"You can not upload files from this display kiosk.")
        else:
            return super(WebPage, self).chooseFile(webFrame, suggestedFileName)

    def acceptNavigationRequest(self, frame, request, navigationType):
        return True


class KioskTab(QWidget):
    def __init__(self, tabs):
        super(KioskTab, self).__init__()
        self.tabs = tabs

        self.view = QWebView()
        self.view.setPage(WebPage(self))
        self.view.statusBarMessage.connect(self.onStatusBarMessage)
        self.view.loadStarted.connect(self.onLoadStarted)
        self.view.loadProgress.connect(self.onLoadProgress)
        self.view.loadFinished.connect(self.onLoadFinished)
        self.view.page().printRequested.connect(self.onPrintRequested)
        self.view.page().windowCloseRequested.connect(self.onWindowCloseRequested)
        self.view.setContextMenuPolicy(Qt.NoContextMenu)
        self.view.installEventFilter(self)

        self.statusBar = QStatusBar()
        self.statusBar.setVisible(not self.tabs.settings.hide_status)
        self.progressBar = QProgressBar()
        self.statusBar.addPermanentWidget(self.progressBar)

        self.resetAction = QAction(self.tabs.settings.reset_text, self)
        self.resetAction.setIcon(self.style().standardIcon(QStyle.SP_BrowserStop))
        self.resetAction.triggered.connect(self.onResetAction)

        self.backAction = QAction(self)
        self.backAction.setIcon(self.view.pageAction(QWebPage.Back).icon())
        self.backAction.triggered.connect(self.onBackAction)

        self.toolBar = QToolBar()
        self.toolBar.setVisible(not self.tabs.settings.hide_toolbar)
        self.toolBar.setToolButtonStyle(Qt.ToolButtonTextBesideIcon)
        self.toolBar.addAction(self.resetAction)
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.backAction)
        self.toolBar.addAction(self.view.pageAction(QWebPage.Forward))
        self.view.pageAction(QWebPage.Forward).setText("")
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.view.pageAction(QWebPage.Reload))
        self.view.pageAction(QWebPage.Reload).setText("")

        layout = QVBoxLayout()
        layout.addWidget(self.toolBar, 0)
        layout.addWidget(self.view, 1)
        layout.addWidget(self.statusBar, 0)
        self.setLayout(layout)
        self.layout().setContentsMargins(0, 0, 0, 0)

        i = self.tabs.addWidget(self)
        self.tabs.setCurrentIndex(i)

    def onResetAction(self):
        self.tabs.reset()

    def onWindowCloseRequested(self):
        if self.tabs.count() > 1:
            self.tabs.removeWidget(self)

    def onStatusBarMessage(self, message):
        self.statusBar.showMessage(message)

    def onLoadStarted(self):
        self.progressBar.setVisible(True)

    def onLoadFinished(self, ok):
        self.progressBar.setVisible(False)

    def onLoadProgress(self, progress):
        self.progressBar.setValue(progress)

    def onPrintRequested(self, frame):
        self.statusBar.showMessage(u"You can not print from this display kiosk.")

    def onBackAction(self):
        if self.view.pageAction(QWebPage.Back).isEnabled():
            self.view.back()
        else:
            self.onWindowCloseRequested()

    def eventFilter(self, obj, event):
        if event.type() == QEvent.KeyPress or event.type() == QEvent.MouseMove:
            self.tabs.notIdle()

        return super(KioskTab, self).eventFilter(obj, event)


class Kiosk(QStackedWidget):
    def __init__(self, settings):
        super(Kiosk, self).__init__()
        self.settings = settings
        self.reset()


        if self.settings.auto_reload:
            self.reloadTimer = QTimer()
            self.reloadTimer.timeout.connect(self.onReloadTimeout)
            self.reloadTimer.start(1000)
            self.reloadCountdown = self.settings.auto_reload
        else:
            self.reloadCountdown = None

        if self.settings.auto_scroll:
            self.scrollTimer = QTimer()
            self.scrollTimer.timeout.connect(self.onScrollTimeout)
            self.scrollTimer.start(self.settings.auto_scroll_interval)

        self.notIdle()

    def onReloadTimeout(self):
        self.reloadCountdown -= 1

        if self.reloadCountdown <= 30:
            for i in range(0, self.count()):
                tab = self.widget(i)
                tab.resetAction.setText("%s (%d)" % (self.settings.reset_text, max(0, self.reloadCountdown)))

        if self.reloadCountdown <= 0 and not self.settings.auto_scroll:
            self.reset()
            self.notIdle()

    def notIdle(self):
        if self.reloadCountdown <= 30:
            for i in range(0, self.count()):
                tab = self.widget(i)
                tab.resetAction.setText("%s" % self.settings.reset_text)

        self.reloadCountdown = self.settings.auto_reload

    def onScrollTimeout(self):
        frame = self.currentWidget().view.page().mainFrame()
        if not self.scrollFrame(frame):
            if self.settings.auto_reload and self.reloadCountdown <= 0:
                self.reset()
                self.notIdle()
            else:
                self.resetFrameScrollBars(frame)

    def scrollFrame(self, frame):
        delta = self.settings.auto_scroll_delta
        maximum = frame.scrollBarMaximum(Qt.Vertical)

        if maximum == 0:
            for childFrame in frame.childFrames():
                if self.scrollFrame(childFrame):
                    return True
            return False
        else:
            if frame.scrollBarValue(Qt.Vertical) >= maximum:
                return False
            else:
                frame.setScrollBarValue(Qt.Vertical, frame.scrollBarValue(Qt.Vertical) + delta)
                return True

    def resetFrameScrollBars(self, frame):
        frame.setScrollBarValue(Qt.Vertical, 0)
        for childFrame in frame.childFrames():
            self.resetFrameScrollBars(childFrame)

    def reset(self):
        while self.count():
            self.removeWidget(self.widget(0))

        tab = KioskTab(self)
        tab.view.page().mainFrame().load(QUrl(self.settings.url))

    def closeEvent(self, event):
        if self.settings.prevent_close:
            self.reset()
            event.ignore()
            return False
        else:
            return super(Kiosk, self).closeEvent(event)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description=__doc__,
        epilog="""See /usr/share/doc/display-kiosk/examples for a sample
                  ~/.xinitrc file. Do not forget to make it executable.""")

    parser.add_argument("--hide-cursor",
        action="store_true",
        help="""Hide the cursor.""")

    parser.add_argument("--hide-status",
        action="store_true",
        help="""Do not show a status bar.""")

    parser.add_argument("--hide-toolbar",
        action="store_true",
        help="""Do not show a toolbar.""")

    parser.add_argument("--reset-text",
        default="Reset",
        help="""The label of the reset button in the toolbar.""")

    parser.add_argument("--prevent-close",
        action="store_true",
        help="""Ignore close events. A window manager might still provide ways
                to kill a process or minimize a window and must be locked down
                seperately.""")

    parser.add_argument("--prevent-upload",
        action="store_true",
        help="""Do not allow uploading files with upload dialogs.""")

    parser.add_argument("--auto-scroll",
        action="store_true",
        help="""Automatically scroll down.""")

    parser.add_argument("--auto-scroll-delta",
        type=int,
        default=300,
        help="""Number of pixels to scroll down per step. Ignored if
                --auto-scroll is not given. Defaults to 300.""")

    parser.add_argument("--auto-scroll-interval",
        type=int,
        default=5000,
        help="""Enables auto scrolling at the given number of milliseconds per
                step. Default is 5000.""")

    parser.add_argument("--auto-reload",
        type=int,
        default=None,
        help="""Number of seconds after which the page should be automatically
                reloaded. Will only reload when keyboard and mouse
                are idle. Will end all sessions. If auto scrolling is enabled
                the reload will be  deferred until scrolling reaches the end.
                The default is not to auto reload at all.""")

    parser.add_argument("--window",
        action="store_true",
        help="""Open in a window rather than fullscreen.""")

    parser.add_argument("url",
        help="""The URL of the website to display.""")


    settings = parser.parse_args()

    app = QApplication([])

    proxy = QNetworkProxyFactory.systemProxyForQuery(QNetworkProxyQuery(QUrl(settings.url)))
    if proxy:
        QNetworkProxy.setApplicationProxy(proxy[0])

    if settings.hide_cursor:
        QApplication.setOverrideCursor(Qt.BlankCursor)

    kiosk = Kiosk(settings)
    kiosk.setWindowTitle("Display kiosk")
    kiosk.setWindowIcon(QIcon("display-kiosk.ico"))
    if settings.window:
        kiosk.show()
    else:
        kiosk.showFullScreen()

    app.exec_()
